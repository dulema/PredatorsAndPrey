<html>
<head>
<title>Software Engineering Design Project - Help</title>
</head>
<body>
<h1>Software Engineering Final Design Project!</h1>
<h2>Predator &amp; Prey Simulation Help</h2>

<font face="Courier New">
<h4>Brought to you by:</h4> 
<pre>	Sandro Badame
        Anthony DiFiore
        Christopher Eichel
        Christopher Perro
        Deniz Ulema</pre>
<h4>Original Idea:</h4>
<pre>	Dr. DeBonis</pre>
<a NAME="top"><h3>Table of Contents</h3></a>
<ol type="I">
	<li><a href="#bsumm">Brief Summary</a></li>
	<li><a href="#howto">How to use</a></li>
	<li><a href="#techinfo">Technical Information</a></li>
	<li><a href="#faqs">FAQ's</a></li>
</ol>
<pre>
----
<a NAME="bsumm"><h4>I.Brief Summary</h4></a>(excerpt from the design document)
	Dr. Debonis suggested this idea to us. It is known as a &quot;Predator &amp; Prey Simulation&quot;.
Basically, there is a world and two types of organisms known as predators and prey. 
Their goals in life are to live as long as possible, and to survive each organism
type must eat. Predators eat prey, and prey eat plants. The world where these
organisms exist is made up of tiles. Imagine a sphere made of hexagonal shaped tiles.
Each and every hexagonal tile represents a location in the world. The simulation
will run in generations made up of turn-based rounds. After each generation finishes,
the best organism of each category, predator and prey, will be saved for the next generation. 
The current generation consists of organisms having characteristics similar to the best
organisms of the previous generation but with mutations, and the best of the previous 
generation again. After that new generation has run through its rounds, the best will be
taken again, and the cycle shall repeat.

<a href="#top">Back to table of contents</a>
----
<a NAME="howto"><h4>II.How to use this program</h4></a>
Once the program window is open you will see areas to:</pre><font face="Courier New" size="1.5">
<ul><li>Left area</li>
	<ul><li>Input the number of generations</li>
		<li>Input the number of predators per generation</li>
		<li>Input the number of prey per generation</li>
		<li>Adjust the size of the map</li>
		<li>Adjust particular details of the map such as:</li>
			<ul><li>Sight range</li>
			<li>Map size</li>
			<li>Percentage of map covered by plants</li>
			<li>Percentage of map covered by prey</li>
			<li>Percentage of map covered by predators</li>
			<li>How many bites can be taken from a plant before it dissapears</li>
			<li>Maximum hunger value of the critters</li>
			<li>Percentage of the pdf you'd like to manipulate due to mutations</li>
			<li>The value of how much you'd like mutations to increment</li>
			<li>Chunks of distance(i.e. 3 represents near, middle, far)</li>
			<li>Chunks of hunger(i.e. 3 represents starving, hungry, sated)</li>
			</ul>
		<li>Apply the mutation (This will change into a progress bar.</li>
		<li>View the histogram of the current best predator</li>
		<li>View the histogram of the current best prey</li
	</ul>
	<li>Right area</li>
	<ul><li>Legend</li>
		<li>Adjust the speed of the current animation</li>
		<li>Adjust the viewing size of the map (zooms in and out)</li>
		<li>Run an animation of the current round</li>
	</ul>
</font></ul><pre>
If you do not wish to adjust anything and simply run the program, there are default
values set, so you may simply click mutate and/or animate.

Note: If you are typing into one of the input fields (number of predators per generation,
number of prey per generation, number of generations, size of map) in the main windows
be sure to enter valid data. The program automatically checks if you are properly 
entering valid data though, just in case.

<a href="#top">Back to table of contents</a>
----
<a NAME="techinfo"><h4>III.Technical Information</h4></a>
This program was written in the Python programming language, version 2.6.
It is designed to take advantage of multi-core machines, due to some of the
calculations being extremely intensive.

Required Features:
	Python 2.6
	Python Tk
	Python Tk-image

Optional feature(s):
	psyco (only availiable on 32-bit OS's, but will greatly increase program performance)


<u>Installation Instructions</u>
On Windows:
	Please visit <a target="_blank" href="http://www.python.org/download/">http://www.python.org/download/</a>
	Click the first link, "Python 2.6.5 Windows installer"
	Download it, follow the instructions

On Linux:
        Open a terminal
	Type "sudo-apt get install python" without the "'s


<u>How to run the program</u>
On Windows:
        Locate src/animatepredatorprey.py
        Double click the animatepredatorprey.py file

On Linux:
        Open a terminal in the proper directory
	Type "python src/animatepredatorprey.py"

<a href="#top">Back to table of contents</a>
----
<a NAME="faqs"><h4>IV.FAQ's</h4></a>
Here are some common questions answered...
<ol>
  <li>What does this program do?</li>
	This program simulates the relationship between predators and prey and the process
        of evolution.

  <li>What are some important concepts?</li>
	Organism/Critter = a predator or a prey
	Vegetation/Plant/Shrub = food that prey eat
	World/Map = the representation of the world, made of hexagons
	Hierarchy of the program:
		Whole Program
			Generation - made up of rounds
				Round - made up of turns, the simulation is turn-based after all
                                        Turn

  <li>What "things" are on the map?</li>
	"Things" can be divided into types of organisms and vegetation. There are two types of
        organisms: predators and prey. Vegetation represent non-critter food.

  <li>What do predators eat?</li>
        Prey.

  <li>What do prey eat?</li>
        Vegetation.

  <li>What is vegetation?</li>
	Vegetation is meant to represent food that prey eat, such as plants and shrubs.
        Vegetation does not move or evolve, but it depletes as it is eaten by prey.

  <li>What eats predators?</li>
        Nothing.

  <li>Can one type of organism eat the other type of organism's food as well?</li>
        No.

  <li>Does cannibalism exist in this program?</li>
        No.

  <li>How do predators and prey decide how to behave?</li>
	Predators and prey each look at the world around them and get sensory data
	(i.e. direction of nearest predator, distance of nearest predator, direction
	of nearest prey, distance of nearest prey, etc.). Based on the sensory data
	they currently have, they look at a pdf, a probability density function. Based
        on the percentages in that pdf, they execute the chosen action.

  <li>Err....What?</li>
	Organisms basically take in sensory data, and based on that data they make a decision
	on what to do.

	Ok first take a deep breath. Good? Now then, let's take a very simplified example. 
	Pretend that you have a simple organism, a prey, that has only two kinds of sensory data:

	Direction of nearest vegetation: 0-1
	Distance of nearest vegetation: 0-1
	(these values can only be 0 or 1 here)

	Because the organism has only two kinds of sensory data that it can detect
	there is a square (a 2 by 2 figure) with four pdf's in it at the corners. At each of the
	corners of the square there is a pdf, represented by a histogram (basically a vertical bar
	graph). The histogram at the top left has let's say 3 bars, the left bar representing "move
	top left" and has a height of 0.2, the middle bar representing "move left" and has a height
	of 0.3, and the right bar representing "don't move anywhere" and has a 	height of 0.5. In a
	pdf, the sum of the heights of the bars in its histogram must add up to 1. The histograms
	at each of the corners of the square have three bars as well that add up to 1, but the 
	height of each bar is different. Therefore the square represents all the possible
	combinations of sensory input. Remember that our hexagonal shaped tiles have only 7 possible
	valid moves: top left, top right, right, bottom right, bottom left, left, and don't move.
	Also remember that this a simplified example.

	00---01
	|     |
	10---11

	Ok, so now let's say that the sensory input data is 0 for direction of nearest vegetation, and
	0 for distance of nearest vegetation. The histogram at the top left of the square is looked at.
	

	0.5			     ||
	                             ||
	0.3		||           ||
			||	     ||
	0.2_||__________||___________||____
	   top left    left      no moving
	
	The program then takes a weighted choice of which action to execute. While there is a chance that
	ANY of the actions may get executed, the MOST LIKELY one the get executed is the action with the
        largest bar, in this case "don't move anywhere" will most likely get chosen.

        Note that in the actual program, the number of sensory data values is largers, thus the pdf's will
        be larger, and the shape will not be a square, but a multidimensional figure that is quite difficult
        to picture that we like to call a hypercube.

    <li>Was that ASCII art?</li>
        Oh yeah.

    <li>What are "mutations" in terms of this program?</li>
        A mutation is defined as a different reaction to the same sensory data. In the program, a mutation
        will be a different reaction to a certain set of sensory data. The following is an example of a
        mutation of the previous simple pdf.

	0.7			     ||
	                             ||
	0.2		||           ||
			||	     ||
	0.1_||__________||___________||____
           top left    left      no moving

        Probabilities for performing each individual action have been adjusted. In the program, a certain
        amount of the pdf's in the hypercube for each critter will be "mutated".

</ol>

<a href="#top">Back to table of contents</a>




</font><center>
&#169;2010, SB AD CE CP DU
</center></pre>
</body>
</html>
